# MEDORO 10 ‚Äì Secuencias y Bloques por OT\n\n> **Objetivo:** incorporar dos vistas nuevas para consolidar eventos en *bloques de producci√≥n/preparaci√≥n por OT y por d√≠a*, generar un √≠ndice de secuencia global estable y habilitar ordenamientos/controles robustos desde Power BI.\n\n---\n\n## üß± Vistas incluidas\n\n1) **`dbo.ConCuboSecuenciasBloques`**  \
   Colapsa filas de `ConCubo3A√±osSecFlag` en **bloques por OT** cuando la misma OT contin√∫a sin intercalarse otra distinta, **a nivel de d√≠a**. Devuelve totales (buenos/malos/horas), rangos de inicio/fin del bloque, *sort key* estable y *rankings* por d√≠a.\n\n2) **`dbo.ConCuboSecuenciasBloques_Rango`**  \
   Extiende la anterior agregando **`OrdenGlobalText`** (clave de ordenamiento textual) y **`SecuenciaGlobalSQL`** (**√≠ndice global 1..N** que no se reinicia por d√≠a ni por filtros).\n\n---\n\n## üì¶ Fuente de datos y supuestos clave\n- Base: **`ConCubo3A√±osSecFlag`** (eventos ya corregidos de fecha y con flags).\n- Se descartan filas **sin `Inicio_Corregido` o `Fin_Corregido`**.\n- Se suman m√©tricas: `HorasProd`, `HorasPrep`, `HorasPara`, `HorasMant`, `CantBuenos`, `CantMalos`.\n- **Cambio de OT** detectado con `LAG(ID_Limpio)` **particionado por `Renglon`** y ordenado por `Inicio_Corregido`.\n- **Agrupaci√≥n diaria:** cada bloque es por **OT + Rengl√≥n + D√≠a**.\n- Enriquecimiento con `saccod1` desde `TablaVinculadaUNION` (v√≠a `TRY_CAST(OP AS INT)` y `ISNUMERIC(OP)=1`).\n\n---\n\n## üîë Campos principales (salida)\n**`ConCuboSecuenciasBloques`**\n- `Renglon`, `ID`, `ID_Limpio`, `saccod1`\n- `CodProducto` (del bloque), `FechaSecuencia` (date), `InicioSecuencia`, `FinSecuencia`\n- Totales: `BuenosTotal`, `MalosTotal`, `HorasProd`, `HorasPrep`, `HorasPara`, `HorasMant`\n- `FilasColapsadas` (conteo de filas originales dentro del bloque)\n- **Ordenaci√≥n y control por d√≠a:**\n  - `NumeroBloqueDiaSQL`: ordinal global del **d√≠a** (todas las m√°quinas)\n  - `NumeroBloqueDiaPorRenglonSQL`: ordinal del **d√≠a** por `Renglon`\n- **`SortKey`**: bigint creciente por **(hora + rengl√≥n + OT)** para ordenar/ranquear en PBI\n\n**`ConCuboSecuenciasBloques_Rango`** (adem√°s):\n- **`OrdenGlobalText`**: `yyyyMMddHHmmss` + `Renglon(4)` + `ID_Limpio(10)`\n- **`SecuenciaGlobalSQL`**: `ROW_NUMBER()` global por `(InicioSecuencia, Renglon, ID_Limpio)`\n\n---\n\n## ‚ùì¬øPor qu√© dos vistas y no una?\n- **`ConCuboSecuenciasBloques`** es la **vista base** para anal√≠tica diaria y KPIs por bloque.\n- **`ConCuboSecuenciasBloques_Rango`** agrega llaves/√≠ndices **globales** para **controles de rango**, comparativas a trav√©s del tiempo y **scroll ordenado** en Power BI, sin recalcular en el modelo.\n\n---\n\n## üßÆ L√≥gica de bloques (resumen)\n1. Orden cronol√≥gico por `Inicio_Corregido` **dentro de cada `Renglon`**.\n2. **Nuevo bloque** cuando cambia `ID_Limpio` respecto del `LAG`.\n3. Se numera acumulativamente con `SUM(CambioID)` ‚Üí `GrupoOT`.\n4. Se agrupa por **`Renglon, GrupoOT, ID, ID_Limpio, CONVERT(date, Inicio_Corregido)`** para consolidar el **bloque diario**.\n5. Se calculan totales y fechas de **inicio/fin** del bloque.\n\n---\n\n## üß∞ Definiciones (SQL)\n\n> **Vista 1 ‚Äì `dbo.ConCuboSecuenciasBloques`**\n\n```sql\nCREATE OR ALTER VIEW dbo.ConCuboSecuenciasBloques AS\nWITH VU AS (\n    SELECT TRY_CAST(OP AS INT) AS ID_Limpio, MIN(saccod1) AS saccod1\n    FROM dbo.TablaVinculadaUNION\n    WHERE ISNUMERIC(OP)=1\n    GROUP BY TRY_CAST(OP AS INT)\n),\nBase AS (\n    SELECT\n        s.Renglon, s.ID, s.ID_Limpio,\n        s.Inicio_Corregido, s.Fin_Corregido,\n        CAST(ISNULL(s.CantidadBuenosProducida,0) AS DECIMAL(18,4)) AS CantBuenos,\n        CAST(ISNULL(s.CantidadMalosProducida ,0) AS DECIMAL(18,4)) AS CantMalos,\n        CAST(ISNULL(s.Horas_Produccion       ,0) AS DECIMAL(18,6)) AS HorasProd,\n        CAST(ISNULL(s.Horas_Preparacion      ,0) AS DECIMAL(18,6)) AS HorasPrep,\n        CAST(ISNULL(s.Horas_Parada           ,0) AS DECIMAL(18,6)) AS HorasPara,\n        CAST(ISNULL(s.Horas_Mantenimiento    ,0) AS DECIMAL(18,6)) AS HorasMant,\n        s.CodProducto\n    FROM dbo.ConCubo3A√±osSecFlag s\n    WHERE s.Inicio_Corregido IS NOT NULL AND s.Fin_Corregido IS NOT NULL\n),\nMarcado AS (\n    SELECT *,\n        CASE WHEN LAG(ID_Limpio) OVER (PARTITION BY Renglon ORDER BY Inicio_Corregido)=ID_Limpio\n             THEN 0 ELSE 1 END AS CambioID\n    FROM Base\n),\nGrupos AS (\n    SELECT *,\n        SUM(CambioID) OVER (PARTITION BY Renglon ORDER BY Inicio_Corregido\n                            ROWS BETWEEN UNBOUNDED PRECEDING AND CURRENT ROW) AS GrupoOT\n    FROM Marcado\n),\nDia AS (\n    SELECT\n        Renglon, ID, ID_Limpio, GrupoOT,\n        CONVERT(date, Inicio_Corregido) AS FechaSecuencia,\n        MIN(Inicio_Corregido) AS InicioSecuencia,\n        MAX(Fin_Corregido)    AS FinSecuencia,\n        MAX(CodProducto)      AS CodProducto_Bloque,\n        SUM(CantBuenos)       AS BuenosTotal,\n        SUM(CantMalos)        AS MalosTotal,\n        SUM(HorasProd)        AS HorasProd,\n        SUM(HorasPrep)        AS HorasPrep,\n        SUM(HorasPara)        AS HorasPara,\n        SUM(HorasMant)        AS HorasMant,\n        COUNT(*)              AS FilasColapsadas\n    FROM Grupos\n    GROUP BY Renglon, GrupoOT, ID, ID_Limpio, CONVERT(date, Inicio_Corregido)\n)\nSELECT\n    d.Renglon, d.ID, d.ID_Limpio,\n    d.CodProducto_Bloque AS CodProducto,\n    d.FechaSecuencia,\n    CONVERT(varchar(16), d.InicioSecuencia, 120) AS FechaSecuenciaTextoHora, -- YYYY-MM-DD HH:MM\n    d.InicioSecuencia, d.FinSecuencia,\n    d.BuenosTotal, d.MalosTotal, d.HorasProd, d.HorasPrep, d.HorasPara, d.HorasMant,\n    d.FilasColapsadas,\n\n    ROW_NUMBER() OVER (\n        PARTITION BY d.FechaSecuencia\n        ORDER BY d.InicioSecuencia, d.Renglon, d.ID_Limpio\n    ) AS NumeroBloqueDiaSQL,\n\n    ROW_NUMBER() OVER (\n        PARTITION BY d.FechaSecuencia, d.Renglon\n        ORDER BY d.InicioSecuencia, d.ID_Limpio\n    ) AS NumeroBloqueDiaPorRenglonSQL,\n\n    CAST(FORMAT(d.InicioSecuencia,'yyyyMMddHHmmss') AS bigint) * 10000000000\n      + CAST(d.Renglon AS bigint) * 1000000000\n      + CAST(d.ID_Limpio AS bigint)                 AS SortKey,\n\n    VU.saccod1\nFROM Dia d\nLEFT JOIN VU ON VU.ID_Limpio = d.ID_Limpio;\nGO\n```\n\n> **Vista 2 ‚Äì `dbo.ConCuboSecuenciasBloques_Rango`**\n\n```sql\nCREATE OR ALTER VIEW dbo.ConCuboSecuenciasBloques_Rango AS\nSELECT\n    d.*,\n\n    -- üîë clave de orden estable (texto: fecha-hora + rengl√≥n + OT)\n    FORMAT(d.InicioSecuencia,'yyyyMMddHHmmss')\n    + RIGHT('0000' + CAST(d.Renglon AS varchar(4)), 4)\n    + RIGHT('0000000000' + CAST(d.ID_Limpio AS varchar(10)), 10) AS OrdenGlobalText,\n\n    -- üî¢ √≠ndice GLOBAL 1..N (NO se reinicia por d√≠a ni por filtro)\n    ROW_NUMBER() OVER (\n        ORDER BY d.InicioSecuencia, d.Renglon, d.ID_Limpio\n    ) AS SecuenciaGlobalSQL\nFROM dbo.ConCuboSecuenciasBloques AS d;\nGO\n```\n\n---\n\n## üß™ Controles y validaciones sugeridas\n1) **Integridad temporal**  
```sql\nSELECT TOP (50) *\nFROM dbo.ConCuboSecuenciasBloques\nORDER BY SortKey;\n```\n- Verificar que el orden cronol√≥gico coincide con `InicioSecuencia` y que no hay inversiones.\n\n2) **Cruce con totales originales**  
```sql\nSELECT ID_Limpio, FechaSecuencia,\n       SUM(HorasProd) AS HorasProd_Bloques,\n       SUM(HorasPrep) AS HorasPrep_Bloques\nFROM dbo.ConCuboSecuenciasBloques\nGROUP BY ID_Limpio, FechaSecuencia;\n```\n- Comparar contra la tabla de detalle para una OT/d√≠a.\n\n3) **Secuencia global estable**  
```sql\nSELECT TOP (50) SecuenciaGlobalSQL, OrdenGlobalText, *\nFROM dbo.ConCuboSecuenciasBloques_Rango\nORDER BY SecuenciaGlobalSQL;\n```\n- Confirmar que no se reinicia y que avanza de forma consistente.\n\n4) **Distribuci√≥n por rengl√≥n y d√≠a**  
```sql\nSELECT FechaSecuencia, Renglon, COUNT(*) AS Bloques\nFROM dbo.ConCuboSecuenciasBloques\nGROUP BY FechaSecuencia, Renglon\nORDER BY FechaSecuencia, Renglon;\n```\n\n---\n\n## üìä Uso recomendado en Power BI\n- **Tabla de Bloques (hechos):** `ConCuboSecuenciasBloques`\n  - Ordenar por **`SortKey`** para narrativas temporales.\n  - Slicers por `FechaSecuencia`, `Renglon`, `ID_Limpio`, `saccod1`, `CodProducto`.\n  - KPIs: `%Prep = DIVIDE(SUM(HorasPrep), SUM(HorasProd))`, \n    `%Parada = DIVIDE(SUM(HorasPara), SUM(HorasProd))`, etc.\n- **Controles de rango/scroll:** `ConCuboSecuenciasBloques_Rango`\n  - Usar `SecuenciaGlobalSQL` para **paginado l√≥gico** o bookmarks.\n  - `OrdenGlobalText` como etiqueta/clave al exportar o depurar.\n- **Relaciones:** si existen tablas por **OT** o **Producto**, relacionar por `ID_Limpio` y/o `CodProducto` (tener en cuenta granularidades).\n- **Evitar jerarqu√≠a autom√°tica de fecha**: usar `FechaSecuencia` (date) y, cuando se necesite hora exacta, **`InicioSecuencia`** (datetime) o el campo **`FechaSecuenciaTextoHora`** como texto legible en visuales que no deben jerarquizar.\n\n---\n\n## ‚ö†Ô∏è Notas y performance\n- **SQL Server 2014+**: las funciones usadas (`TRY_CAST`, `FORMAT`, `LAG`, `ROW_NUMBER`) est√°n disponibles. `FORMAT` es conveniente pero m√°s costoso; mantener su uso acotado a claves de ordenamiento.\n- **ISNUMERIC(OP)=1** puede aceptar algunos formatos no deseados (como exponentes). Si aparecen casos raros, considerar un filtro m√°s estricto (ej.: `OP NOT LIKE '%.%' AND OP NOT LIKE '%e%'`).\n- **Granularidad**: los bloques son **por d√≠a**. Si una OT contin√∫a al d√≠a siguiente, **se abre un nuevo bloque**.\n- **Filas colapsadas**: √∫til para detectar eventos muy fragmentados.\n\n---\n\n## üß≠ Casos de uso t√≠picos\n- **Timeline ordenado de producci√≥n/preparaci√≥n** por m√°quina u OT.\n- **Control diario de sequenciaci√≥n**: usar `NumeroBloqueDiaSQL` para validar el orden del shopfloor.\n- **An√°lisis de eficiencia** por bloque: horas de preparaci√≥n vs producci√≥n, paradas, mantenimiento.\n- **Auditor√≠a**: exportar con `OrdenGlobalText` para reproducir √≥rdenes en Excel.\n\n---\n\n## üß∑ Fragmentos √∫tiles (SQL)\n**1) √öltimos N bloques por m√°quina**\n```sql\nSELECT TOP (200) *\nFROM dbo.ConCuboSecuenciasBloques\nWHERE Renglon = 201\nORDER BY SortKey DESC;\n```\n\n**2) Foto de un d√≠a (todas las m√°quinas)**\n```sql\nSELECT *\nFROM dbo.ConCuboSecuenciasBloques\nWHERE FechaSecuencia = '2025-06-11'\nORDER BY NumeroBloqueDiaSQL;\n```\n\n**3) Secuencia global en rango**\n```sql\nSELECT *\nFROM dbo.ConCuboSecuenciasBloques_Rango\nWHERE SecuenciaGlobalSQL BETWEEN 12000 AND 12100\nORDER BY SecuenciaGlobalSQL;\n```\n\n**4) KPI simple por OT**\n```sql\nSELECT ID_Limpio,\n       SUM(HorasProd) AS HProd,\n       SUM(HorasPrep) AS HPrep,\n       100.0 * SUM(HorasPrep)/NULLIF(SUM(HorasProd),0) AS Prep_pct\nFROM dbo.ConCuboSecuenciasBloques\nGROUP BY ID_Limpio\nORDER BY Prep_pct DESC;\n```\n\n---\n\n## üìù Changelog (Medoro 10)\n- ‚úÖ Nueva vista `ConCuboSecuenciasBloques` con consolidaci√≥n diaria por bloques y *sort key* estable.\n- ‚úÖ Nueva vista `ConCuboSecuenciasBloques_Rango` con **√≠ndice global** y **clave textual** para ordenamiento/export.\n- ‚úÖ Gu√≠a de integraci√≥n con Power BI y validaciones SQL.\n\n---\n\n## üìå Pr√≥ximos pasos sugeridos\n- Agregar **medidas DAX** est√°ndar al modelo (eficiencias, ratios, OEE si aplica).\n- Crear una **p√°gina de control** en PBI con *SecuenciaGlobalSQL* para navegar bloques.\n- Incorporar `saccod1` en segmentaciones y matrices de detalle.\n- (Opcional) Versionar una **tabla materializada** nocturna si el volumen crece y la latencia de vistas resulta alta.\n\n---\n\n## üë§ Autor\n**Marcelo F. L√≥pez Castro** ‚Äì Proyecto MEDORO 10  
SQL Server ¬∑ Power BI ¬∑ Data Analytics\n

